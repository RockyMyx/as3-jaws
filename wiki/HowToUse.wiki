#summary A guide on how to use JAWS

= Table of contents =
<wiki:toc max_depth="3" />

= How to use JAWS =
=== Server side definition ===
In the following examples we have a webservice located at http://www.exampleurl.com/service.asmx. The webservice contains following methods: 
  * HelloWorld():String
  * HelloName(name:String):String
  * getUser():User
  * insertUser(newUser:User):void

There is also a class called "User" defined like this:
  * username:String
  * password:String
  * desciple:User

=== Setting up the objects in AS3 ===
First of all we need to create a new webservice object, connected to the URL above (http://www.exampleurl.com/service.asmx).
{{{
var webservice:Webservice = new Webservice("http://www.exampleurl.com/service.asmx");
}}}
There we go, easy huh!? But for now, it doesn't do anything. The webservice class is built to not do anything until has to. Everything is on-demand. Not even the WSDL is downloaded until it has to (unless you want it to). If you want to force the class to download and parse the WSDL you run the downloadWSDL function: 
{{{
var webservice:Webservice = new Webservice("http://www.exampleurl.com/service.asmx");
webservice.downloadWSDL();
}}}

=== Running a parameterless function ===
To run a method there are 2 alternatives. The first one is to run the makeCall function. This functions returns an integer flagging how the call went, which is declared as constants on the Webservice class. If we want to run the HelloWorld method the code beneth will do exactly this: 
{{{
var webservice:Webservice = new Webservice("http://www.exampleurl.com/service.asmx");
webservice.makeCall("HelloWorld");  
}}}
The other way to run a method is to use the fact that Webservice is a proxy, wich means you can run the methods direclty on the object. Like this: 
{{{
var webservice:Webservice = new Webservice("http://www.exampleurl.com/service.asmx");
webservice.HelloWorld();
}}}
Both methods works exactly the same. If the WSDL is not loaded when the method is called, the call is queued and then fired as soon as it is possible.

=== Running a method with parameters ===
To run a method that requires parameters, you have the same choice of method to run it. The first method, makeCall, takes all the rest parameters as parameters to run. If we take HelloName as example, the code under will run the method and use "Calle" as parameter:
{{{
var webservice:Webservice = new Webservice("http://www.exampleurl.com/service.asmx");
webservice.makeCall("HelloName", "Calle");
}}}
And for the proxy version it's even easier!
{{{
var webservice:Webservice = new Webservice("http://www.exampleurl.com/service.asmx");
webservice.HelloName("Calle");
}}}

=== Handling the response ===
The response from the server doesn't come directly. An event is fired asynchronical as soon as it's possible. Because of this you have to set listeners to the Webservice object. The code beneath creates a new webservice object, and then listens to the response and traces it depending on if it went well or not: 
{{{
private var webservice:Webservice;
public function init():void {
	 webservice = new Webservice("http://www.exampleurl.com/service.asmx");
	 webservice.addEventListener(WebserviceEvent.RESPONSE, onResponse);
}
private function onResponse(event:WebserviceEvent):void {
	 if(event.success) {
		 trace("The call went well!");
	 } else {
		 trace("An error occured when the method was called");
		 trace(event.faultCode + ": " + event.faultDescription);
	 }
}
}}}
The following code will run the HelloWorld method and the trace out the response ("Hello World")
{{{
private var webservice:Webservice;
public function init():void {
	 webservice = new Webservice("http://www.exampleurl.com/service.asmx");
	 webservice.addEventListener(WebserviceEvent.RESPONSE, onResponse);
	 webservice.HelloWorld();
}
private function onResponse(event:WebserviceEvent):void {
	 if(event.success) {
		 trace(event.response); //HelloWorld
	 } else {
		 trace("An error occured when the method was called");
		 trace(event.faultCode + ": " + event.faultDescription);
	 }
}
}}}

=== Running a method with a callback function ===
The other way to handle the response is to use a callback function. Both methods works almost the same. The reason for the both to be here is to provide a wide variety of ways to handle the response to best suite the need and style of the developer. The function that handles the response must have two parameters, success(Boolean) and returnObject(Object). The names can of course be changed, but there need to be one bool and one object. The bool specifies if the call went well, and the object is the returned object from the server (lazydecoded, ie. it will be a as3 object). When using this method all responses are lazydecoded. To make a call and handle the event with a function the code below can be used: 
{{{
private var webservice:Webservice;
public function init():void {
	 webservice = new Webservice("http://www.exampleurl.com/service.asmx");
	 webservice.makeCallWithCallback("HelloWorld", helloWorldResponse);
}
private function helloWorldResponse(success:Boolean, returnObject:Object):void {
	 trace(success + ": " + returnObject);
}
}}}

=== Complex Types ===
Sometimes you will have to deal with complex types. Complex types are objects that isn't simple (DUH!?), which means other than string, numbers and booleans. These are defined in the WSDL and the developer doesn't need to worry about this. In this example we have a complex type, the User object, and we are going to create a new User, fill in the username and password and then send the object to the server using the webservice method insertUser.
{{{
private var webservice:Webservice;
public function init():void {
	 webservice = new Webservice("http://www.exampleurl.com/service.asmx");

	 var user:Object = new Object();
	 user.username = "Calle";
	 user.password = "foo";

	 webservice.insertUser(user);
}
}}}
Easy isn't it? Next we will add so we first insert the user, then get all users and show the information about theese:
{{{
private var webservice:Webservice;
public function init():void {
	 webservice = new Webservice("http://www.exampleurl.com/service.asmx");
	 webservice.addEventListener(WebserviceEvent.RESPONSE, onResponse);

	 var user:Object = new Object();
	 user.username = "Calle";
	 user.password = "foo";

	 webservice.insertUser(user);
	 webservice.getUser();
}
private function onResponse(event:WebserviceEvent):void {
	 if(event.success) {
		 trace(event.name); //getUser
		 trace(event.response.username); //Calle
		 trace(event.response.password); //foo
		 trace(event.response.desciple); //null
		 if(desciple != null) {
			 trace(event.response.desciple.username);
			 trace(event.response.desciple.password);
			 trace(event.response.desciple.desciple);
		 }
	 } else {
		 trace("An error occured when the method was called");
		 trace(event.faultCode + ": " + event.faultDescription);
	 }
}
}}}
Great! Now then, lets try even more complex types, lets add a desciple to the user we insert:
{{{
private var webservice:Webservice;
public function init():void {
	 webservice = new Webservice("http://www.exampleurl.com/service.asmx");
	 webservice.addEventListener(WebserviceEvent.RESPONSE, onResponse);

	 var user:Object = new Object();
	 user.username = "Calle";
	 user.password = "foo";

	 var user2:Object = new Object();
	 user2.username = "Yoda"; //HAHA
	 user2.password = "foo2";

	 user.desciple = user2; //Yoda becomes Calles desciple, splendid!

	 webservice.insertUser(user);
	 webservice.getUser();
}
private function onResponse(event:WebserviceEvent):void {
	 if(event.success) {
		 trace(event.name); //getUser
		 trace(event.response.username); //Calle
		 trace(event.response.password); //foo
		 trace(event.response.desciple); //[Object object]
		 if(desciple != null) {
			 trace(event.response.desciple.username); //Yoda
			 trace(event.response.desciple.password); //foo2
			 trace(event.response.desciple.desciple); //null
		 }
	 } else {
		 trace("An error occured when the method was called");
		 trace(event.faultCode + ": " + event.faultDescription);
	 }
}
}}}